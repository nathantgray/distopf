"""
plot.py - Plotly visualization functions for LinDistModel results
"""

import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

from distopf import LinDistModel

# plot color codes for distribution system plots

COLORCODES = {
    # key: circuit element type
    # values: color, linewidth
    "transformer": ["black", 4, "solid"],
    "switch": ["black", 4, "solid"],
    "line": ["black", 4, "solid"],
    "reactor": ["black", 4, "solid"],
}


def plot_voltages(v: pd.DataFrame = None) -> go.Figure:
    """
    Parameters
    ----------
    v : pd.DataFrame, Dataframe containing solved voltages for each bus.
        Typically generated by the LinDistModel.get_voltages() method.

    Returns
    -------
    fig : Plotly figure object
        Plotly figure object containing the voltage magnitudes for each bus.
    """
    v = v.melt(ignore_index=False, id_vars=["id", "name"], var_name="phase", value_name="v")
    fig = px.scatter(v, x=v.name, y="v", facet_col="phase", color="phase")
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1].upper()))
    fig.for_each_xaxis(lambda a: a.update(title="Bus Name"))
    return fig


def compare_voltages(v1: pd.DataFrame, v2: pd.DataFrame) -> go.Figure:
    """
    Visually compare voltages by plotting two different results.
    Parameters
    ----------
    v1 : pd.DataFrame
    v2 : pd.DataFrame

    Returns
    -------
    fig : Plotly figure object
    """
    v1 = v1.melt(ignore_index=True, var_name="phase", id_vars=["id", "name"], value_name="v1")
    v2 = v2.melt(ignore_index=True, var_name="phase", id_vars=["id", "name"], value_name="v2")
    v = pd.merge(v1, v2, on=["name", "phase"])
    fig = px.line(v, x="name", facet_col="phase", y=["v1", "v2"], markers=True)
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1].upper()))
    fig.for_each_xaxis(lambda a: a.update(title="Bus Name"))
    return fig


def voltage_differences(v1: pd.DataFrame, v2: pd.DataFrame) -> go.Figure:
    """
    Visually compare voltages from two different results by plotting the difference v1-v2.
    Parameters
    ----------
    v1 : pd.DataFrame
    v2 : pd.DataFrame

    Returns
    -------
    fig : Plotly figure object
    """
    v1["id"] = v1.index
    v2["id"] = v2.index
    v1 = v1.melt(ignore_index=True, var_name="phase", id_vars=["id", "name"], value_name="v1")
    v2 = v2.melt(ignore_index=True, var_name="phase", id_vars=["id", "name"], value_name="v2")
    v = pd.merge(v1, v2, on=["id", "phase"])
    v["diff"] = v["v1"] - v["v2"]
    fig = px.line(v, x="id", y="diff", facet_col="phase")
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1].upper()))
    fig.for_each_xaxis(lambda a: a.update(title="Bus Name"))
    return fig


def plot_power_flows(s: pd.DataFrame) -> go.Figure:
    """
    Plot the active and reactive power flowing into each bus on each phase.
    Parameters
    ----------
    s : pd.DataFrame

    Returns
    -------
    fig : Plotly figure object
    """

    s = s.melt(
        ignore_index=True, id_vars=["fb", "tb", "from_name", "to_name"], var_name="phase", value_name="s"
    )
    s["p"] = s.s.apply(lambda x: x.real)
    s["q"] = s.s.apply(lambda x: x.imag)
    del s["s"]
    s = s.melt(
        ignore_index=True,
        id_vars=["fb", "tb", "from_name", "to_name", "phase"],
        var_name="part",
        value_name="power",
    )
    fig = px.bar(
        s,
        x="tb",
        y="power",
        facet_col="phase",
        facet_row="part",
        color="phase",
        labels={"tb": "To-Bus Name"},
    )
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1].upper()))
    fig.update_layout(
        yaxis4_title="Active Power (p.u.)",
        yaxis_title="Reactive Power (p.u.)",
    )
    return fig


def compare_flows(s1: pd.DataFrame, s2: pd.DataFrame) -> go.Figure:
    """
    Similar to plot_power_flows but plots two results side by side.
    Parameters
    ----------
    s1 : pd.DataFrame
    s2 : pd.DataFrame

    Returns
    -------
    fig : Plotly figure object
    """
    s1 = s1.melt(
        ignore_index=True, id_vars=["fb", "tb", "from_name", "to_name"], var_name="phase", value_name="s"
    )
    s1["p"] = s1.s.apply(np.real)
    s1["q"] = s1.s.apply(np.imag)
    del s1["s"]
    s1 = s1.melt(
        ignore_index=True,
        id_vars=["fb", "tb", "phase"],
        var_name="part",
        value_name="s1",
    )
    s2 = s2.melt(
        ignore_index=True, id_vars=["fb", "tb", "from_name", "to_name"], var_name="phase", value_name="s"
    )
    s2["p"] = s2.s.apply(np.real)
    s2["q"] = s2.s.apply(np.imag)
    del s2["s"]
    s2 = s2.melt(
        ignore_index=True,
        id_vars=["fb", "tb", "phase"],
        var_name="part",
        value_name="s2",
    )
    s = pd.merge(s1, s2, on=["fb", "tb", "phase", "part"], how="outer")
    fig = px.bar(
        s,
        x="tb",
        y=["s1", "s2"],
        facet_col="phase",
        facet_row="part",
        barmode="group",
        labels={"tb": "To-Bus Name"},
    )
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1].upper()))
    fig.update_layout(
        yaxis4_title="Active Power (p.u.)",
        yaxis_title="Reactive Power (p.u.)",
    )
    return fig


def plot_ders(ders: pd.DataFrame) -> go.Figure:
    """
    Plot the generated power for each DER.
    Parameters
    ----------
    ders : pd.DataFrame

    Returns
    -------
    fig : Plotly figure object
    """
    dec_var = ders.melt(
        ignore_index=False,
        var_name="phase",
        value_name="Generated Power (p.u.)",
        id_vars="name",
    )
    fig = px.bar(
        dec_var,
        x=dec_var.name,
        y="Generated Power (p.u.)",
        color="phase",
        barmode="group",
        labels={"name": "DER Bus Name"},
    )
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1]).upper())
    return fig


def plot_polar(p: pd.DataFrame, q: pd.DataFrame) -> go.Figure:

    p = p.melt(
        ignore_index=False,
        var_name="phase",
        value_name="p",
        id_vars="name",
    )

    q = q.melt(
        ignore_index=False,
        var_name="phase",
        value_name="q",
        id_vars="name",
    )
    pq = pd.merge(p, q, on=["name", "phase"], how="outer")
    pq["s"] = (pq.p.array + 1j * pq.q.array).astype(complex)
    pq["r"] = np.abs(pq.s)
    pq["th"] = np.angle(pq.s, deg=True)
    fig = px.scatter_polar(
        pq,
        r="r",
        theta="th",
        color="phase",
        range_theta=[-90, 90],
        start_angle=0,
        direction="counterclockwise",
    )
    return fig


def plot_network(
    model: LinDistModel,
    v: pd.DataFrame = None,
    s: pd.DataFrame = None,
    p_gen: pd.DataFrame = None,
    q_gen: pd.DataFrame = None,
    v_min: int = 0.95,
    v_max: int = 1.05,
    show_phases: str = "abc",
    show_reactive_power: bool = False,
) -> go.Figure:
    """
    Plot the distribution network showing voltage and power results.
    Parameters
    ----------
    model : LinDistModel
    v : pd.DataFrame, (default=None) Dataframe containing voltage magnitudes for each bus.
    s : pd.DataFrame, (default=None) Dataframe containing power flows for each branch.
    p_gen : pd.DataFrame, (default=None) Dataframe containing actve power generated by each generator.
    q_gen : pd.DataFrame, (default=None) Dataframe containing reactive power generated by each generator.
    v_min : (default=0.95) Used for scaling node colors.
    v_max : (default=1.05) Used for scaling node colors.
    show_phases : (default="abc") valid options: "a", "b", "c", or "abc"
    show_reactive_power : (default=False) If True, show reactive power flows instead of active power flows.

    Returns
    -------
    fig: plotly.graph_objects.Figure
    """
    _v = None
    _s = None
    if s is not None:
        _s = s.copy()
    if v is not None:
        _v = v.copy()
    # validate phases
    if show_phases.lower() not in ["a", "b", "c", "abc"]:
        raise ValueError("Invalid phase. Must be 'a', 'b', 'c', or 'abc'.")
    show_phases = show_phases.lower()
    phase_list = sorted([ph.lower() for ph in show_phases])
    bus_data = model.bus.copy()
    branch_data = model.branch.copy()
    gen_data = model.gen.copy()
    cap_data = model.cap.copy()

    node_size = 10
    edge_scale = 10
    edge_min = 1

    bus_data = _process_bus_data(bus_data, _v, phase_list)
    branch_data = _process_branch_data(branch_data, bus_data, _s, phase_list, edge_scale, edge_min)
    gen_data = _process_gen_data(gen_data, p_gen, q_gen)

    node_trace = _make_node_trace(bus_data, node_size, v_max, v_min)
    cap_trace, gen_trace, substation_trace = _make_asset_markers(bus_data, cap_data, gen_data, node_size)
    edge_traces = _make_edge_traces(branch_data, show_phases, show_reactive_power)
    reverse_flow_markers_trace = _make_reverse_flow_marker_trace(branch_data, node_size, show_reactive_power)

    node_trace.text = _make_hover_text(branch_data, bus_data, cap_data, gen_data)
    title = _make_title(show_phases, show_reactive_power)

    fig = go.Figure(
        data=[
            *edge_traces,
            substation_trace,
            reverse_flow_markers_trace,
            cap_trace,
            gen_trace,
            node_trace,
        ]
    )

    fig.update_layout(
        title=title,
        plot_bgcolor="White",
        paper_bgcolor="White",
        title_font_color="Black",
        legend_font_color="Black",
        legend_bgcolor="White",
        margin=dict(t=50, b=10, l=10, r=10),
        xaxis=dict(visible=False),
        yaxis=dict(visible=False),
        legend=dict(x=0.8, y=0.9),
        font=dict(family="Droid Sans Mono", color="Black"),
        # annotations=arrow_list[0:1],
    )

    return fig

def _process_bus_data(bus_data, _v, phase_list):
    bus_data["y"] = bus_data.latitude - bus_data.latitude.mean()
    bus_data["x"] = bus_data.longitude - bus_data.longitude.mean()
    bus_data["color"] = "white"
    if bus_data.x.abs().max() > 0:
        bus_data.x = bus_data.x / bus_data.x.abs().max()
    if bus_data.y.abs().max() > 0:
        bus_data.y = bus_data.y / bus_data.y.abs().max()
    if _v is not None:
        _v.index = _v.id - 1
        bus_data.v_a = _v.a
        bus_data.v_b = _v.b
        bus_data.v_c = _v.c
        bus_data.color = _v[phase_list].mean(axis=1)
    return bus_data


def _process_branch_data(branch_data, bus_data, _s, phase_list, edge_scale, edge_min):
    branch_data = branch_data.loc[branch_data.status != "OPEN", :]
    branch_data.index = branch_data.tb.to_numpy() - 1
    branch_data["s_a"] = complex(np.nan, np.nan)
    branch_data["s_b"] = complex(np.nan, np.nan)
    branch_data["s_c"] = complex(np.nan, np.nan)
    branch_data["p_abs"] = 1
    branch_data["q_abs"] = 1
    branch_data["p_norm"] = edge_min
    branch_data["q_norm"] = edge_min
    branch_data["p_direction"] = 1
    branch_data["q_direction"] = 1
    branch_data["x0"] = bus_data.loc[branch_data.fb.to_numpy() - 1].x.to_numpy()
    branch_data["x1"] = bus_data.loc[branch_data.tb.to_numpy() - 1].x.to_numpy()
    branch_data["y0"] = bus_data.loc[branch_data.fb.to_numpy() - 1].y.to_numpy()
    branch_data["y1"] = bus_data.loc[branch_data.tb.to_numpy() - 1].y.to_numpy()
    branch_data["x_mid"] = 1 / 2 * (branch_data.x0 + branch_data.x1)
    branch_data["y_mid"] = 1 / 2 * (branch_data.y0 + branch_data.y1)
    if _s is not None:
        _s.index = _s.tb.to_numpy() - 1
        branch_data["s_a"] = _s.a
        branch_data["s_b"] = _s.b
        branch_data["s_c"] = _s.c
        branch_data["p_abs"] = np.abs(np.real(_s.loc[:, phase_list].sum(axis=1)))
        branch_data["q_abs"] = np.abs(np.imag(_s.loc[:, phase_list].sum(axis=1)))
        branch_data["p_norm"] = (
            branch_data["p_abs"].to_numpy() / branch_data["p_abs"].max() * edge_scale + edge_min
        )
        branch_data["q_norm"] = (
            branch_data["q_abs"].to_numpy() / branch_data["q_abs"].max() * edge_scale + edge_min
        )
        branch_data["p_direction"] = np.sign(np.real(_s.loc[:, phase_list].sum(axis=1)) + 1e-6)
        branch_data["q_direction"] = np.sign(np.imag(_s.loc[:, phase_list].sum(axis=1)) + 1e-6)
    return branch_data


def _process_gen_data(gen_data, p_gen, q_gen):
    gen_data.index = gen_data.id.to_numpy() - 1
    if p_gen is not None:
        p_gen.index = p_gen.id.to_numpy() - 1
        gen_data.pa = p_gen.a
        gen_data.pb = p_gen.b
        gen_data.pc = p_gen.c
    if q_gen is not None:
        q_gen.index = q_gen.id.to_numpy() - 1
        gen_data.qa = q_gen.a
        gen_data.qb = q_gen.b
        gen_data.qc = q_gen.c
    return gen_data


def _make_reverse_flow_marker_trace(branch_data, node_size, show_reactive_power):
    if show_reactive_power:
        reverse_list_x = branch_data.loc[branch_data.q_direction < 0, "x_mid"].to_numpy()
        reverse_list_y = branch_data.loc[branch_data.q_direction < 0, "y_mid"].to_numpy()
    else:
        reverse_list_x = branch_data.loc[branch_data.p_direction < 0, "x_mid"].to_numpy()
        reverse_list_y = branch_data.loc[branch_data.p_direction < 0, "y_mid"].to_numpy()
    reverse_flow_markers_trace = go.Scatter()
    if not show_reactive_power:
        reverse_flow_markers_trace = go.Scatter(
            x=reverse_list_x,
            y=reverse_list_y,
            mode="markers",
            marker=dict(
                symbol="star-triangle-up",
                size=node_size * 1,
                color="orange",
                line_width=0.5,
                line_color="black",
            ),
            showlegend=True,
            name="Reverse Power Flow",
            hoverinfo="none",
        )
    return reverse_flow_markers_trace


def _make_edge_traces(branch_data, show_phases, show_reactive_power):
    edge_traces = []
    for _, edge in branch_data.iterrows():
        x0, x1 = edge.x0, edge.x1
        y0, y1 = edge.y0, edge.y1
        dash = COLORCODES.get(edge["type"], ["black", 4, "solid"])[2]
        linewidth = edge.p_norm
        direction = edge.p_direction
        if show_reactive_power:
            linewidth = edge.q_norm
            direction = edge.q_direction
        if (
                show_phases.lower() != "abc"
                and show_phases.lower() not in edge.phases.lower()
        ):
            dash = "dot"

        color = "darkblue"
        if direction < 0:
            color = "maroon"
        edge_trace = go.Scatter(
            x=[x0, x1],
            y=[y0, y1],
            mode="lines",
            line=dict(color=color, width=linewidth, dash=dash),
            showlegend=False,
        )
        edge_traces.append(edge_trace)
    return edge_traces


def _make_hover_text(branch_data, bus_data, cap_data, gen_data):
    text = [f"Bus: '{name}'      A   ||   B   ||   C" for name in bus_data["name"]]
    for i, bus_row in enumerate(bus_data.itertuples()):
        # if _v is not None:
        va = bus_row.v_a
        vb = bus_row.v_b
        vc = bus_row.v_c
        text[i] = text[i] + f"<br>    |V|:      {va:.3f}  {vb:.3f}  {vc:.3f}"

        pla = bus_row.pl_a
        plb = bus_row.pl_b
        plc = bus_row.pl_c
        qla = bus_row.ql_a
        qlb = bus_row.ql_b
        qlc = bus_row.ql_c
        text[i] += f"<br>    P-Load: {pla:.3f}  {plb:.3f}  {plc:.3f}"
        text[i] += f"<br>    Q-Load: {qla:.3f}  {qlb:.3f}  {qlc:.3f}"

        if cap_data is not None:
            if bus_row.id in cap_data.id.to_numpy():
                q_cap = cap_data.loc[
                    cap_data.id == bus_row.id, ["qa", "qb", "qc"]
                ].to_numpy()[0]
                text[
                    i
                ] += f"<br>    Q-Cap:  {q_cap[0]:.3f}  {q_cap[1]:.3f}  {q_cap[2]:.3f}"

        if bus_row.id in gen_data.id.to_numpy():
            p_gen = gen_data.loc[gen_data.id == bus_row.id, ["pa", "pb", "pc"]].to_numpy()[0]
            q_gen = gen_data.loc[gen_data.id == bus_row.id, ["qa", "qb", "qc"]].to_numpy()[0]
            text[i] += f"<br>    P-Gen:  {p_gen[0]:.3f}  {p_gen[1]:.3f}  {p_gen[2]:.3f}"
            text[i] += f"<br>    Q-Gen:  {q_gen[0]:.3f}  {q_gen[1]:.3f}  {q_gen[2]:.3f}"
        edge = branch_data.loc[branch_data.tb == bus_row.id, :]
        if len(edge) == 0:
            continue
        to_name = bus_row.name
        fb = edge.fb.to_numpy()[0]
        from_name = bus_data.loc[bus_data.id == fb, "name"].to_numpy()[0]
        sa, sb, sc = edge.s_a.to_numpy()[0], edge.s_b.to_numpy()[0], edge.s_c.to_numpy()[0]
        new_text = (
            f"<br>Branch {from_name}â†’{to_name}"
            f"<br>    P flow:  {np.real(sa):.3f}  {np.real(sb):.3f}  {np.real(sc):.3f}"
            f"<br>    Q flow:  {np.imag(sa):.3f}  {np.imag(sb):.3f}  {np.imag(sc):.3f}"
        )
        text[i] += new_text
    return text


def _make_title(show_phases, show_reactive_power):
    title = f"<b>Network Plot (P.U.)</b>"
    # if _v is not None:
    title = title + "<br>Node color: "
    if show_phases == "abc":
        title = title + "Average voltage magnitude"
    else:
        title = title + f"Phase-{show_phases.upper()} voltage magnitude"
    # if _s is not None:
    title = title + "<br>Line width:"
    if show_phases == "abc":
        title = title + " Total"
    else:
        title = title + f" Phase-{show_phases.upper()}"
    if show_reactive_power:
        title = title + " <i>reactive</i> power flow"
    else:
        title = title + " <i>active</i> power flow"
    title = title + " (reverse flow in red)."
    return title


def _make_asset_markers(bus_data, cap_data, gen_data, node_size):
    # Add substation marker
    substation_buses = bus_data.loc[bus_data.bus_type == "SWING", :]
    substation_trace = go.Scatter(
        x=substation_buses["x"],
        y=substation_buses["y"],
        mode="markers",
        marker=dict(
            symbol="square",
            size=node_size * 2,
            color="black",
            line_width=1,
            line_color="black",
        ),
        showlegend=True,
        name="Substation",
        hoverinfo="none",
    )
    # Add generator markers
    gen_buses = bus_data.loc[bus_data.id.isin(gen_data.id), :]
    gen_trace = go.Scatter(
        x=gen_buses["x"],
        y=gen_buses["y"],
        mode="markers",
        marker=dict(
            symbol="square",
            size=node_size * 2,
            color="white",
            line_width=1,
            line_color="black",
        ),
        showlegend=True,
        name="Generators",
        hoverinfo="none",
    )
    # Add capacitor markers
    cap_buses = bus_data.loc[bus_data.id.isin(cap_data.id), :]
    cap_trace = go.Scatter(
        x=cap_buses["x"],
        y=cap_buses["y"],
        mode="markers",
        marker=dict(
            symbol="star-diamond",
            size=node_size * 2,
            color="white",
            line_width=1,
            line_color="black",
        ),
        showlegend=True,
        name="Capacitors",
        hoverinfo="none",
    )
    return cap_trace, gen_trace, substation_trace


def _make_node_trace(bus_data, node_size, v_max, v_min):
    node_trace = go.Scatter(
        x=bus_data["x"],
        y=bus_data["y"],
        mode="markers",
        marker=dict(
            showscale=True,
            cmin=v_min,
            cmax=v_max,
            # colorscale options
            # 'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |
            # 'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |
            # 'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' | 'Aggrnyl'
            colorscale="Viridis",
            reversescale=False,
            size=node_size,
            color=bus_data.color,
            line_width=node_size / 5,
            line_color="black",
        ),
        showlegend=False,
        text=bus_data["name"],
        hovertemplate="%{text}",
        textposition="top center",
    )
    return node_trace
